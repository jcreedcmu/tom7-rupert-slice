(*   -*- electric-indent-local-mode: -1 -*- *)
let
  import "stdlib.bovex"
  import "layout.bovex"
  import "palatino.bovex"
  import "cite.bovex"
  import "ruperts.bib"

  import "solution-table.bovex"

  val doc-title = "Some upsetting things about shapes"
  val doc-subtitle = "There’s no subtitle either"

  do set-doc-info {(PDFInfo)
                   width = inch 8.5,
                   height = inch 11.0,
                   creator = "BoVeX",
                   producer = "Huh?",
                   title = doc-title,
                   author = "Tom 7",
                   subject = "Documents do not need a 'subject'"
                   (* leaving out date, so it is the creation time. *) }

  val tt = fixedersys

  fun body-font lay = span
    {(Span)
     font-face = font-family PALATINO,
     font-size = 12.0,
     line-spacing = 1.0 } lay

  fun sup lay =
    span {(Span) font-size = 8.0,
          (* Don't rephrase the text in these. *)
          no-rephrase = true } lay

  fun footnote s = [([b[footnote]]: [s])]

  val next-figure-id = ref 1
  fun figure-id () =
    let val s = int-to-string (!next-figure-id)
    in
      next-figure-id := !next-figure-id + 1;
      layout s
    end

  val ROLL-PITCH-YAW = figure-id()

  fun make-sol-table () =
    let

      (* for positive f, return g * 10^e such that 1.0 <= g < 10.0. *)
      fun exp-notation f =
        if f >=. 10.0
        then let val (g, e) = exp-notation (f /. 10.0)
             in (g, e + 1)
             end
        else if f <. 1.0
             then
               let val (g, e) = exp-notation (f *. 10.0)
               in (g, e - 1)
               end
             else (f, 0)

      fun render-finite-float f =
        if f <. 0.0
        then [-[render-finite-float (0.0 -. f)]]
        else
          let
            val ipart : int = trunc f
            val fpart : float = int-to-float ipart -. f
          in
            if ipart >= 1000000 andalso ipart <= 100000000
            then layout (int-to-string ipart)
            else
              let
                val (g, exp) = exp-notation f

                (* now render g as a fixed number of decimal
                   points. *)
                val n = round (g *. 1000000.0)
                val s = int-to-string n
                do string-size s != 7
                   andthen fail ("huh? " ^ s)
              in
                layout (string-prefix (s, 1)) ^^ [.] ^^
                layout (substr-rest (s, 1)) ^^
                (if exp == 0
                 then []
                 else [×10[sup (layout (int-to-string exp))]])
              end
          end

      fun render-float f =
        if float-is-nan f then ["NaN"]
        else if f ==. float-inf then [∞]
             else if f ==. float-inf then [-∞]
                  else render-finite-float f

      fun make-box lay =
        get-boxes (layout-map-text normalize-whitespace lay)

      fun one-row (_, name, NONE) =
        (get-boxes (layout name),
         get-boxes [?],
         get-boxes [?])
        | one-row (_, name, SOME(ratio, clearance)) =
        (get-boxes (layout name),
         get-boxes (render-float ratio),
         get-boxes (render-float clearance))

      val rows = list-map one-row solution-table

      fun rec nil = []
        | rec ((name, r, c) :: rest) =
        name ^^ r ^^ c ^^ hfill() ^^ break() ^^
        rec rest
    in
      rec rows
    end

in

(main-text (body-font
[
 [title (layout doc-title)]
 [sub-title (layout doc-subtitle)]

 [author[Dr. Tom Murphy VII, Ph.D.]][date[March 2025]]

 How big is the unit cube? “1?” Seems obvious, right?
 Let me ask you another way: [it[Where]] is the unit cube? “0?”

 Or: How big is the unit sphere? “1?” Imagine I am asking you these
 questions where pounce upon you with the next question just as
 you start to answer the first. To keep you off your balance,
 I mean. [it[Where]] is the unit sphere? “0?” Which is bigger, the
 unit cube or the unit sphere? Sweating yet?

 “Officially” speaking, the unit cube has edge length 1, and
 has all non-negative home coordinates, like ({0, 1}, {0, 1}, {0, 1}).
 According to those same math referees, the unit sphere has [it[radius]]
 1, and its center at (0, 0, 0).

 So the unit cube fits easily within the unit sphere. I don't know
 about you, but I always imagine the idealized cube and sphere
 centered on the origin, with the sphere tucked inside the cube,
 touching its sides at their centers.[footnote[The long-running
 ThursDz's Beer Society of Math Geniuses decided that what I am
 actually imagining is not the unit cube but the "L-infinity unit
 sphere," which I think may be true but sounds like I'm just trying to
 be an asshole.]]

 ... shrinkwrap ...

 Does the unit sphere fit inside the

 Now that I’ve gotten the "dice in sphere" pun out of the way, we can
 move onto the real topic of this paper.

 Late some night I was admiring the Wikipedia article on the
 Dodecahedron, my favorite Platonic solid. On this page I was reminded
 that the Dodecahedron is Rupert, like the cube. This seemed right,
 since if the cube has a pleasing property and the Dodecahedron is
 awesome, it should also have that pleasing property. This is of
 course not true. For example, the cube can tile space and the
 dodecahedron obviously cannot. The property of having pleasing
 properties is itself pleasing, though, and throughout history
 people have ... (Bertrand Russell, Godel)

 Indeed, all the Platonic solids have the Rupert property. The Platonic
 solids are beautiful and so the fact that all of them have this pleasing
 property recommends it further. Then I read the phrase “it has been
 conjectured that all 3-dimensional convex polyhedra have this
 property,” which made my brain feel surprised but happy. I might have
 even gotten to sleep, had I stopped reading at that moment. But then I
 read “of the 13 Archimedean solids, it is known that at least ten have
 the Rupert property,” and this made my brain surprised and angry. How
 could it be the case that we think this is true for *all* convex
 polyhedra (infinitely many, and mostly gigantic weird ugly ones) but
 we don’t know for some 3 simple beautiful ones? Did nobody check? It
 seemed to me it would be pretty easy to write a search procedure that
 would look for them, and it also seemed like if we think it’s
 possible, it would be easy to find solutions.

Here were my Naive Heuristics:
[ul

 ([This is a continuous problem. If you have some way of fitting the
  shape through itself, then there will be some adjacent small
  variation on that that will also work. Problems where the solution
  needs to be exact (e.g. problems on integers) tend to be much
  harder. These solutions won’t need to be exact because of [it[NO
  TOUCHING!]] ] ::

 [This might be a problem that not that many people have tried (only
  stamp collectors), since serious mathematicians would be interested
  in a real solution (i.e. a proof that the general conjecture is
  true).] ::

 [I am definitely not the best mathematician to have tried this, but
  it’s possible that I’m the best programmer to try it, and plausible
  that nobody has tried it with a very fast and hot GPU.] ::

 [I can whip this up in a day (or maybe a weekend) and then put it
  aside if I can’t solve it.] ::

 nil)]

So I set aside two and a half months to work on it.

This problem is pretty easy to specify precisely. The shape in
question is a convex polyhedron, which is just defined by its set of
vertices. For general polyhedra you also need to specify how those
vertices are connected (the edges and faces), but convex polyhedra are
easier. There’s just one way to stretch a “skin” over the points, so
we don’t even need to describe it (or even think about it). We’ll take
two copies of the points. One is the “outer” polyhedron and one is the
“inner”. The goal is to find some way of arranging them so that the
inner can pass through the outer.

The inner one will pass through the outer along some line, so we say
without loss of generality that this is the z axis. We’ll use the
computer graphics convention that the camera is located at some
positive z, looking down at the shapes, which are near the origin, and
the inner polyhedron is moving along this same line of sight. Maybe
like it’s shooting out of our eyeballs as a kind of abstract weapon of
geometry. A Platomic Bomb. Viewed this way, what it means for the
inner shape to be able to pass through the outer is that the two
dimensional “shadow” of the inner shape is entirely contained within
the shadow of the outer shape.

We’ll specify the arrangement of the polyhedra as a rotation and
translation; together these are a rigid frame (hereafter just
“frame”). Because we know we’re traveling along the z axis, the z
component of the translations are unimportant and we can just consider
2D translations. Moreover, since we just care about the relative
positions of the objects, we can say that the outer polyhedron is
fixed at (0,0). We need to be able to rotate both shapes arbitrarily,
though.

The inner shadow being completely contained within the outer shadow is
intuitive, but we should be more precise. The convex hull of a set of
2D points is the minimal convex polygon that contains them all (here
“contains” includes the boundary); this is the same idea as the
minimal skin around the vertices of our convex polyhedron. To get the
shape of the shadow, we just project the object to 2D along the z axis
(easy: (x, y, z) just becomes (x, y)) and then compute the convex hull
of the points using standard algorithms. Now we can just ask whether
the inner hull is entirely contained within the outer hull. Since
the outer hull is convex, this amounts to a standard test that
each point on the inner hull is contained within a convex 2D polygon.
You can find slightly buggy code for this all over the internet.
(There are many alternative formulations, some of which are discussed
below.)

The boundary condition here is very important. The inner points must
be [it[strictly]] contained within the outer hull (less-than, not
less-than-or-equal), never exactly on the boundary or coincident with
an outer vertex. If we allow them to be on the hull, then carving the
inner through the outer would make the residue disconnected (perhaps
dramatically so). It also makes the problem trivial: If the outer and
inner have the same frame, then their shadows are also the same, and
the inner one is trivially (weakly) inside the outer. If you think
this amounts to “passing one cube through the other and leaving a
proper hole”, then you and I disagree about what proper hole means.

So to solve the Rupert problem for some shape, you need to find two
rigid frames that satisfy the above (and we know that one of the
translations can be (0, 0, 0) and the other (x, y, 0)). How do we find
such frames?

If you have a fast enough test, sampling will suffice for easy objects
like the cube. Here you just generate random frames and test whether
the condition holds. You can try all orientations and reasonable
bounds on the translation (you do not want to translate more than the
diameter of the cube, for example, or it will definitely not go
through it)!

[subsection[Generating random orientations]]

Generating random numbers is easy using floating point roundoff error[cite murphy2023grad]. How do you generate a random rotation (orientation)?
There are a few different ways to specify a rotation. You can use
Euler angles, which are three parameters that give the rotation around
the x, y, and z axes (“pitch,” “roll,” and “yaw”; see Figure [ROLL-PITCH-YAW]). This
approach actually sucks (famously, Euler was not that good at math).
You can get all orientations this way, but you will get some
orientations more often than others.[footnote[Euler rotation is
accomplished by rotating along each axis in turn. Imagine gimbal lock:
Rotate the Earth such that ... The density of parameters that are
close to this gimbal lock position is much higher.]] Maybe that is
okay for you (or Eu-ler) but I want all orientations to be equally
likely.

[image { img = image-load "roll_pitch_yaw_mnemonic.png",
         width = inch 3.65 }]
Figure [ROLL-PITCH-YAW].
Wikipedia[cite wikipedia-roll-pitch-yaw] provides this useful mnemonic
for remembering which axis corresponds to each of the three words. The
[b[pitch]]er makes sense, since you famously use a pitcher by holding
the handle away from you and turning your wrist to pour diagonally
towards yourself. But d[b[oor]] must just be trolling, right?

A good way to do this is using Quaternions, the even more mysterious
second cousins of the complex numbers. I will not try to give you an
intuition for quaternions (since I do not really have one) but they
can be used as a four-parameter representation of orientations that
will leave you happy (and puzzled) instead of sad (and puzzled). Facts
to know about the Quaternions:

[ul([Most people don’t capitalize Quaternions.] ::

    [Like complex numbers where you have a + b[b[i]], here we have a +
    b[b[i]] + c[b[j]] + d[b[k]]. The parameters are (a, b, c, d) and
    [b[i]], [b[j]], [b[k]] are “even more imaginary” “constants” that
    have some impossible relations, like [b[i]][sup[2]] = -1 but also
    [b[ijk]] = -1] ::

    [You can just think of a quaternion as a four-dimensional vector
    (a, b, c, d). If this is a unit-length vector, then represents an
    orientation. There are exactly two unit quaternions representing
    each unique orientation in 3D. No gimbal lock and no favorites.] ::

    nil)]

A good—but not great—way to generate random 4D unit vectors is to
generate random points on a 4D hypersphere, because these are the same
thing. There are very fancy ways to do this, but you run the risk of
getting the math wrong, or head explosion etc., so I recommend
rejection sampling. Rejection sampling is a very robust way to
generate uniform samples in some set. What you do is generate random
points inside some domain that contains the target set, and throw away
points that aren’t in the target. For example, to generate points in a
unit circle, you can generate points in the 2x2 square (it’s [it[not]]
the unit square) that contains that circle. π/4 of these points will
be in the circle, and so you get samples at an efficiency of about
78.5%.

[image { img = image-load "sample-circle.png", width = inch 3.65 }]

To generate points inside a sphere, you do the same thing, but in a
2x2x2 cube. This sphere has volume 4π/3 and the cube has volume 8,
so you get samples at an efficiency of about 52.4%.

To generate 4D points inside a 4D hypersphere[footnote
[We should say “3-sphere,” or “hyperball”, since the convention
 is that a normal sphere in 3D is called a 2-sphere, since its
 surface is actually two dimensional. It would just seem to add
confusion here, though.]], you do the same thing,
but now the hypervolume is π[sup[2]]/2, and the 4D hypercube has hypervolume
16, so you get samples at an efficiency of about 30.8%.

Upsettingly, as we increase dimensions, the hypervolume of the
[it[n]]-dimensional hypersphere approaches zero (!?) and the
[it[n]]-dimensional hypercube's grows exponentially, so this
technique approaches perfect 0% efficiency.

[image { img = image-load "sample-nd-hypersphere.png", width = inch 3.65 }]

Fortunately, we only need 4D vectors, and 30% efficiency is fine
because my computer can calculate like 1 billion samples per second
and I only need two.

The two samples give the orientations of the outer and inner polyhedra,
and we also pick random positions. We then project to 2D, compute
the convex hulls, and

[subsection[The convex hulls]]

Computing the convex hull is also “standard,” meaning that you can
find lots slightly buggy implementations of various algorithms on the
internet. The bugs are usually because the routines are intended for
computer graphics and so they don't have to “work,” and because the
algorithms are conceptualized in the mathematical world where when you
look at a point that's really close to a line segment, the point stays
on the same side of the line when you look at it from different
directions. This is unfortunately not the case for naive
implementations using floating point. It usually “doesn't matter that
much,” or “just add a magic constant you named epsilon,[cite
murphy2014epsilon]” but unfortunately when you are working with
extremely regular shapes like Platonic solids, you will frequently get
points that are colinear or coplanar and exercise the too-optimistic
beliefs of the code you found. So this is another good way to make
your afternoon project take several months.

You only need to compute the outer hull, but I found it was faster
to compute a convex hull for the inner polyhedron as well. That way
you only need to do the point-in-polygon test for the points on
the inner hull. [* XXX incircle? *]

[subsection[Optimizing]]

Now we can test whether some random orientations and positions (frames)
demonstrate the Rupert property. It is easy to find solutions for
the cube by just sampling. But of course we want to make it faster,
first of all just for the heck of it, but also so that we can solve
the unknown cases, which are presumably harder.

I started with black-box optimization, again using my own twisted
variant of BiteOpt[cite vaneev2024biteopt]. Black box optimization
is good for people like me and Euler who are bad at math.


[subsubsection[Epsilon]]

Speaking of epsilon, and

Infinitely many
What’s the best Rupert?

[subsection[Results]]
[make-sol-table ()]

[section[Improvements to BoVeX]]

To make my life harder, but also more thrilling, I typeset this
paper in BoVeX, which is a document preparation system I wrote
as a joke (?) for SIGBOVIK 2024.[cite murphy2024badness] You can
tell from the way that the math looks like a child typeset it
that I didn't yet implement any fancy layout algorithms for that.

I did, however, spend precious vacation days in the run-up to SIGBOVIK
2025 adding features and fixing other, less important deficiencies of
BoVeX so that I can continue my demented quest to use primarily
software written by myself as a joke (?) instead of the perfectly
decent mainstream software that everybody else uses, and whose lives
are therefore presumably not thrilling in this way. So begins the
Tom 7 SIGBOVIK tradition of listing [it[BoVeX improvements]]:

[paragraph[Unicode]] BoVeX now supports Unicode fonts. I needed this
so that I could write π when I was on a digression about sampling
quaternions. This was so annoying to implement! PDF was defined during
the era where we were just finally realizing that our approach to
character sets and font encoding was unsustainably complicated, and so
they tacked on Unicode as a hack on top of that complicated mess. So
you get all the benefits of the complexity of Unicode and all of the
benefits of the complexity of not Unicode. You actually have to manage
the glyphs yourself, for example, but also tell PDF how big everything
is (but also how big it [it[might be]], just in case it's inconvenient
to actually render it) and you also have to tell it how to decode the
glyphs back into Unicode so that you can search or copy-paste from the
PDF. Ugh! There are a number of undocumented or barely-documented
requirements, and the symptoms of mistakes are that Adobe Acrobat will
tell you “Unable to open [tt[test.pdf]]. Please contact the document
author.” Um, I contacted myself but nothing happened! But now you can
just put UTF-8 in your BoVeX source code and it'll work. Check this
out: Дональд Трамп может поцеловать мою задницу!

[paragraph[FixederSys]] Along those same lines, I extended the
FixederSys font family[cite fixedersys-site] with a lot more Unicode
characters, like the many exotic mathematical symbols that nobody has
ever used. Unicode is even more inspiring to notation fetishists than
[tt[amssymb]] in this regard. It's too bad that the math in this paper
is so elementary, or else we could be like [b (fixedersys[A ≽ B ⊯ ⊱∔C
⊶ ∷D⊰])].

[paragraph["Robustness"]]
BoVeX no longer crashes programs like Adobe Acrobat that expect
the PDFs to be "correct." LOL!!

[section [Bibliography]]

[bibliography()]

]))

end

(*

how big is the unit cube?
let me ask you this way. WHERE is the unit cube?
how big is the unit sphere?
(dice in sphere)

now, most rich ..

 It is just notes for now.

 dice in sphere

 point set version

 illustrate all the hulls

 table of best ratios/clearances

 small noperts

 gpu version
 rational version
 z3 version
   .. decidable

triangle man hates particle man

 I'm definitely asking for it with floating points!!

 upsetting symmetry thing

 you get objects with names like these:
 https://mathworld.wolfram.com/Octahedron.html
 "gyrobifastigium"

 triangle man hates particle man (degenerate triangles)

 what's the best platonic solid?
 icosahedron has a triforce in it (orthogonal projection with face
 parallel to view plane)

 floating space-yogi holding shapes

 meta ruperts.
 We'll always be asking if a shape can fit inside a convex
 solid, which is the original e.g. cube.

 But the cutting shape can be concave. One example would be a
 complex of the inner/outer polyhedra in a rupert configuration.
 Note that the z coordinate of the inner one is not fixed here
 (we could consider it infinite?)

 Then the question is whether we can pass one of these complexes
 through the original solid, giving us a level-2 rupert, and so on.

 If the extrusion is infinite, then this means we won't rotate the
 inner complex, only the outer. So the question becomes: Can we
 find an initial configuration, and a series of outer rotations,
 each of which contains the previous? It's pretty clear that it
 cannot reach a fixed point, since the area of each has to be
 strictly increasing. But it is possible (likely?) that there are
 chains of infinite length (if any exist at all).

 Rather than think of the extrusion as infinite, we could put the
 inner polyhedron at a position of our choice (along the penetrating
 axis). It doesn't even need to be overlapping the outer polyhedron,
 but it seems like you want to, because the next question is whether
 you could pass this whole complex through another original
 polyhedron. Here, rigid transformations of both the outer shape
 and inner complex are permitted (and you have the additional
 optimization parameter of the inner-inner shape's z position).
 Could fixed points exist for this? Maybe?

  it's like a katamari ball

 heuristics: "inadequate equilibrium" is possibly interesting
 here, because it does have this dimension analogy (here it
 is a Blessing of Dimensionality): When optimizing two opposing
 forces on a 1D line, you have no choice but to get stuck.
 When you have two dimensions, it is possible to get trapped in
 a local maximum. Adding more dimensions makes the optimization
 problem potentially easier to solve simply by descent.

 tier

 communing with perverted aliens

 man-made horrors like,
   - typos in unicode
   - conventions about the size of a unit sphere and cube

 *)
